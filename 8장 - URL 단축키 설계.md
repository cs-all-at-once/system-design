# 8장 - URL 단축키 설계
## 1단계 - 문제 이해 및 설계 범위 확정
시스템의 기본적 기능은 아래와 같다.
1. URL 단축(long->shorten)
2. URL 리다이렉션 (축약된 URL을 원래 URL로 안내)
3. 높은 가용성과 규모확장성, 그리고 장애 감내

## 2단계 - 개략석 설계안 제시 및 동의 구하기
이번절에서는 API end point,  URL 리다이렉션, URL 단축플로에 대해 알아본다. 
### API end point
클라이언트는 서버가 제공하는 APIend point로 서버와 통신하게 되는데     
이때 우리는 이를 REST스타일로 설계할 것이다.
<img width="814" alt="image" src="https://github.com/user-attachments/assets/79916df9-2b19-4ac0-8bfc-e9acb48447fd" />

1. URL 단축용 엔드포인트 : POST/api/data/shorten
   - 인자 : longURLstring
   - 반환 : 단축 URL        
2. URL 리다이렉션용 엔드포인트 : GET/api/v1/shortUrl
   - 반환 : HTTP 리디렉션 목적지가 될 원래 URL
### URL 리다이렉션
그럼 위에서 유의할 점은 2번에서의 301과 302 응답차이다.

#### 301 vs 302 리디렉션 동작 차이
<img width="786" alt="image" src="https://github.com/user-attachments/assets/358716c9-5fc8-4c92-b1af-536f57545347" />

1. 301은 브라우저가 "이 URL은 앞으로 이 주소로 이동해"라고 기억해서,     
   → 다음부터는 원래 주소로 바로 요청을 보낸다.     
   → 즉, 단축 URL 서버를 거치지 않는다.     

3. 302는 "지금만 이 주소로 가야 해"이기 때문에,     
→ 클라이언트가 매번 단축 URL 서버에 요청을 보낸다.     
→ 단축 URL 서버는 "지금 누가, 언제, 어디서 클릭했는지" 로그를 남길 수 있다.    

### URL 단축플로
슬슬 단축을 어떻게 할지 알아보자. 
단축 URL을 만들때 가장 중요한 것은 긴 URL을 해시 값으로 대응시킬 해시 함수 fx를 찾는 것이다.    
1. 입력으로 주어지는 긴 URL이 다르면 해시값도 달라야한다.
2. 계산된 해시값은 원래 입력으로 주어졌던 긴 URL로 복원할 수 있어야 한다.

## 3단계 - 상세설계
데이터모델, 해시함수 ,URL 단축 및 리디렉션에 관해 보다 구체적인 설계안을 알아보자.

### 데이터 모델
#### 문제의식
계략적 설계에서 모든걸 해시테이블에 두었는데, 초기전략으론 좋아도 실제 시스템에서는 메모리가 유한하고 비싸기에   
더나은 방법은 <단축 URL , 원래 URL> 순서쌍을 관계형 데이터베이스에 저장하는 것이다.

- 초기에는 모든 데이터를 메모리 기반 해시테이블에 저장 → 빠르지만 메모리 용량이 제한됨.
- 실제 서비스에서는 영속성이 필요하고, 규모가 커질수록 메모리 기반 저장은 한계가 있음.

#### 해결책
<단축 URL, 원래 URL> 형태의 순서쌍을 관계형 DB(예: MySQL, PostgreSQL 등)에 저장.
- 이 구조를 통해:
  1. 서버 재시작 시에도 데이터 유지
  2. 수십억 개의 URL 관리 가능
  3. 인덱싱 등을 통한 효율적인 검색 지원



### 해시함수
원래 URL을 단축 URL로 변환시키는데 사용된다.

해시값의 길이는 62이다. (0-9, A-Z ,a-z)      
해시값의 길이를 정하기 위해 62^N의 최솟값을 찾아야한다.     
(n=7 이면 3.5조 개를 만들 수 있다.)     

해시함수를 구현하는 방법은 두가지로 나뉜다.
###  해시후 충돌 해소 vs base-62 변환
해시 후 충돌 해소
개념:
* 일반 해시 함수 (예: SHA256, MD5 등)를 사용하여 원래 URL을 해시
* 해시된 결과값 일부를 잘라서 사용 (예: 앞 7자리)
* 단, 충돌(같은 해시)이 발생할 수 있음 → 이를 처리하는 로직이 필요
충돌 해결 방식 예시
* 충돌되면 뒤에 숫자를 붙이고 다시 해시하거나
* DB에 존재 여부 확인 후 중복이면 다시 생성
* 또는 원래 URL + 타임스탬프 등으로 해시 변경
장점
* 해시 알고리즘 사용 → 비교적 간단함
* URL이 같으면 같은 해시 → 중복 저장 방지 가능
단점
* 충돌 처리가 필요
* 충돌 처리 로직이 복잡할 수 있음


Base-62 변환 방식
개념:
* DB에서 생성한 고유 숫자 ID (예: Auto Increment 값, UUID 일부 등)를 Base-62로 변환하여 짧은 URL을 만든다.
예시:
* DB에 URL을 저장하고 id=125로 저장됨
* 이 숫자 125를 62진수로 변환하면 → cb
장점
* 충돌 없음 (ID는 고유함)
* URL 생성 속도 빠름
* 구현 간단, 안정적
단점
* URL이 같아도 여러 개의 short URL이 생길 수 있음 (중복 저장)

<img width="829" alt="image" src="https://github.com/user-attachments/assets/a79ad2f5-49dd-4ff0-b7b3-3001528c6e1e" />


### 왜 같은 URL인데도 여러 개의 Short URL이 생기는가?

Base-62 방식은 long URL의 내용이 아닌, 데이터베이스에 저장된 **고유 ID**를 기준으로 단축 URL을 생성한다.
따라서 같은 long URL이 여러 번 요청되더라도, 매번 insert가 이루어지면 서로 다른 ID가 생성되어 다른 short URL이 만들어진다.

#### 예시

* 첫 번째 요청: `https://example.com/hello` → 저장 → ID = 1000 → base62(`1000`) = `g8`
* 두 번째 요청: 같은 URL → 또 저장 → ID = 1001 → base62(`1001`) = `g9`

결과적으로 같은 long URL에 대해 여러 개의 short URL이 생긴다.

#### 원인 요약

| 원인                 | 설명                       |
| ------------------ | ------------------------ |
| Base-62는 DB의 ID 기반 | URL 내용은 고려하지 않음          |
| 중복 확인 없이 저장        | 같은 URL도 다른 ID로 저장됨       |
| 그래서                | 같은 URL에 대해 여러 단축 URL이 생김 |

#### 해결 방법

1. long URL로 먼저 중복 여부를 조회한 뒤:

   ```sql
   SELECT id FROM urls WHERE long_url = ?
   ```

   * 이미 존재하면 해당 ID를 base62로 변환해 반환
   * 없다면 새로 insert 후 ID를 base62로 변환

2. 또는, 해시 기반 방식(MD5 등)을 사용해 같은 long URL은 항상 동일한 short URL이 나오도록 구현할 수도 있음.



##  URL 단축기 상세 설계 

클라이언트가 긴 URL을 보내면 서버는 이를 짧은 URL로 변환하여 반환한다. 전체 과정은 다음과 같다:

1. **입력으로 긴 URL을 받는다**

   * 사용자가 `https://example.com/page/very/long/path` 와 같은 긴 URL을 서버에 전달한다.

2. **데이터베이스에 해당 URL이 있는지 검사한다**

   * 이미 이 URL에 대한 단축 URL이 생성된 적이 있는지 확인하기 위해 DB에서 long URL로 검색한다.

3. **이미 존재한다면 → 기존 단축 URL 반환**

   * 동일한 long URL에 대해 중복 생성을 피하기 위해, 기존에 생성된 short URL을 그대로 반환한다.

4. **존재하지 않는 경우 → 새 URL이므로 ID 생성**

   * 이 URL은 처음 요청된 것이므로 DB에 새 row를 insert한다.
   * 이때 생성되는 auto-increment ID는 고유하다 (예: 12345).

5. **62진법 변환으로 단축 문자열 생성**

   * 생성된 ID(정수)를 62진법 (0–9, a–z, A–Z)으로 변환하여 `abc123` 같은 짧은 문자열을 만든다.
   * 이 문자열이 단축 URL의 핵심이 된다.

6. **DB에 \<ID, 원래 URL, 단축 URL> 저장 후 응답 반환**

   * 위 정보를 DB에 저장한 후, 생성된 단축 URL (`https://short.ly/abc123`)을 클라이언트에 전달한다.

---

##  URL 리디렉션 상세 설계 (Redirect to Original URL)

사용자가 단축 URL을 브라우저에 입력하면, 이 요청은 원래 URL로 리디렉션되어야 한다. 과정은 다음과 같다:

1. **단축 URL의 path segment를 추출**

   * 예: `https://short.ly/abc123` → 추출된 키: `abc123`

2. **해당 키를 base-62에서 10진수로 디코딩**

   * 예: `abc123` → 10진수 ID로 변환 (예: 12345)

3. **ID로 데이터베이스에서 원래 URL을 검색**

   * DB의 primary key(ID)를 사용하여 원래 long URL을 찾는다.

4. **찾은 URL을 Location 헤더에 담아 301 또는 302 응답으로 리디렉션**

   * `HTTP/1.1 302 Found`
     `Location: https://example.com/page/very/long/path`
   * 브라우저는 이 응답을 보고 자동으로 원래 URL로 이동한다.

5. **클릭 횟수나 리퍼러 로그를 저장**

   * 마케팅이나 통계 분석용으로 누가 언제 어떤 단축 URL을 클릭했는지 기록할 수 있다.
