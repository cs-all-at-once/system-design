# 4장 - 처리율 제한 장치의 설계

처리율 제한 장치는 트래픽의 처리율을 제어하기 위한 장치다.
이를 통해 아래와 같은 3가지 이점을 얻을 수 있다.
1. DOS 공격에 대한 자원고갈을 방지
2. 비용절감 - 서버를 적게두어도 되고, 만일 Third-party를 시용한다면 사용료지불이 줄어든다.
3. 서버 과부하를 막는다 - 사용자의 잘못된 이용패턴 혹은 bot에서 오는 트래픽을 막는다.

## 1단계 문제 이해 및 설계 범위 확정
1. 클라이언트 측 or 서버측 어디서 설계해야하는지?
2. 어떤 기준으로 제어규칙을 만들어야하는지? ip주소? id?
3. 시스템 규모가 어느정도 되는지?
4. 분산환경인지 단일서버환경인지?
5. 독립된 서비스로 제공해야하는지 혹은 애플리케이션 코드에 포함시키는지?
6. 사용자에게 요청이 걸러지면 알려야하는지?

## 2단계 개략적 설계안 제시 및 동의 구하기
### 처리율 제한 장치의 위치
일반적으로 클라이언트에 두면 쉽게 위변조가 가능하므로 서버측에 두는것이 좀더 안정적이다.
API서버에 두는것 혹은 API서버와 클라이언트 사이에 API게이트웨이(미들웨어)를 두는 방식이 있다.
구현하고 유지보수하기 까다로울 정도로 인력이 없다면 위탁해서 처리하는 것도 가능하다.

1.프로그래밍 언어, 캐시 등 현재 사용중인 기술스택을 점검하여 알맞는 것을 찾기
2. 처리율 제한 알고리즘도 고려해야한다.(제 3자가 제공하는 경우 스킵)

## 처리율 제한 알고리즘
## 1. 토큰 버킷 (Token Bucket)

<details>
<summary>1. 개념</summary>

- 일정한 비율로 버킷에 토큰이 추가된다.  
- 요청이 들어오면 토큰 하나를 제거하고 요청을 허용한다.  
- 토큰이 없으면 요청은 거부되거나 지연된다.  
- 버스트 트래픽(짧은 시간 동안 몰리는 요청)을 흡수할 수 있다.

</details>

<details>
<summary>2. 예시</summary>

- 초당 5개의 토큰이 생성됨  
- 버킷 최대 용량은 10개  
- 갑작스러운 10개 요청은 모두 허용됨  
- 이후 요청은 초당 5개까지만 허용

</details>

<details>
<summary>3. 장단점</summary>

- 장점  
  - 일정 수준의 버스트 트래픽 수용 가능  
  - 유연한 트래픽 제어 가능  

- 단점  
  - 상대적으로 구현 복잡도 존재  
  - 과도한 누적은 허용되지 않음

</details>

---

## 2. 누출 버킷 (Leaky Bucket)

<details>
<summary>1. 개념</summary>

- 일정한 속도로 요청을 처리한다.  
- 내부 큐에 요청이 들어오고, 일정 간격으로 하나씩 처리된다.  
- 큐가 꽉 차면 초과 요청은 폐기된다.  
- 처리율이 항상 일정하게 유지된다.

</details>

<details>
<summary>2. 예시</summary>

- 초당 1개의 요청만 처리  
- 10개의 요청이 동시에 들어오면  
  - 큐에 저장되며 순차적으로 1초마다 처리됨  
  - 큐가 꽉 차면 이후 요청은 거부

</details>

<details>
<summary>3. 장단점</summary>

- 장점  
  - 일정한 요청 처리율 유지 가능  
  - 구현이 상대적으로 단순함  

- 단점  
  - 버스트 트래픽 수용 불가  
  - 큐의 크기에 따라 지연이 발생할 수 있음

</details>

---

## 3. 고정 윈도 카운터 (Fixed Window Counter)

<details>
<summary>1. 개념</summary>

- 일정 시간 간격(윈도우)으로 요청을 카운트한다.  
- 윈도우 내에서 요청이 설정한 임계값을 넘으면 이후 요청은 차단된다.  
- 시간 단위는 초, 분, 시 등으로 설정할 수 있다.

</details>

<details>
<summary>2. 예시</summary>

- 1분 동안 100개의 요청 허용  
- 같은 분 안에서 100개 요청이 오면 그 뒤 요청은 차단됨  
- 분이 바뀌면 카운터는 0으로 초기화

</details>

<details>
<summary>3. 장단점</summary>

- 장점  
  - 매우 간단한 구현  
  - 메모리 소모가 적음  

- 단점  
  - 시간 경계(윈도우 끝)에서 갑작스러운 요청 증가 허용됨  
  - 경계 조건에서 버스트 가능

</details>

---

## 4. 이동 윈도 로그 (Sliding Window Log)

<details>
<summary>1. 개념</summary>

- 각 요청의 타임스탬프를 로그로 저장  
- 현재 시각 기준으로 일정 시간 내의 요청 수를 계산  
- 일정 시간 내 요청이 한계를 넘으면 차단한다.  
- 경계 문제 없이 정확한 제어가 가능하다.

</details>

<details>
<summary>2. 예시</summary>

- 최근 60초간 최대 100개의 요청 허용  
- 요청이 들어올 때마다 현재 60초 이내 요청 수를 로그에서 계산  
- 100개 이상이면 차단

</details>

<details>
<summary>3. 장단점</summary>

- 장점  
  - 매우 정밀한 제어 가능  
  - 시간 경계 문제 없음  

- 단점  
  - 요청당 로그 저장으로 메모리 소모 큼  
  - 로그 정리 비용 존재 (GC, TTL 처리 필요)

</details>

---

## 5. 이동 윈도 카운터 (Sliding Window Counter)

<details>
<summary>1. 개념</summary>

- 시간을 여러 개의 작은 구간으로 나눈다.  
- 각 구간의 요청 수를 기록하고, 최근 N개의 구간을 합산하여 제한을 판단한다.  
- 로그 없이 정밀한 제어가 가능하다.

</details>

<details>
<summary>2. 예시</summary>

- 1분을 6개의 10초 구간으로 나눔  
- 최근 6개의 구간의 요청 수를 합산  
- 합이 100을 넘으면 차단

</details>

<details>
<summary>3. 장단점</summary>

- 장점  
  - 로그 방식보다 메모리 사용 적음  
  - 경계 문제 해결됨  

- 단점  
  - 구현 복잡도 증가  
  - 시간 동기화 필요

</details>

| 알고리즘              | 실무 사용 빈도 | 핵심 설명                           | 장점                             | 단점                                | 주 사용 사례                       |
|----------------------|----------------|------------------------------------|----------------------------------|-------------------------------------|------------------------------------|
| 토큰 버킷            | ★★★★☆         | 토큰을 일정 속도로 채워 사용       | 버스트 허용, 유연한 처리 가능     | 토큰 관리 필요                      | API Gateway, GCP RateLimiter 등    |
| 누출 버킷            | ★★☆☆☆         | 요청을 일정 속도로 누출             | 처리율 일정, 간단한 구조          | 버스트 처리 불가, 지연 발생 가능    | 네트워크 QoS, 라우터 내부          |
| 고정 윈도 카운터     | ★★★☆☆         | 시간 단위로 요청 수를 제한         | 매우 간단, 메모리 적음            | 윈도 경계에서 버스트 허용           | Redis 기반 간단 RateLimit         |
| 이동 윈도 로그       | ★☆☆☆☆         | 요청 시각을 저장하여 윈도우 계산   | 정확한 제어, 경계 문제 없음       | 로그 저장 공간, 성능 저하 우려      | 학습용/이론적 설명용               |
| 이동 윈도 카운터     | ★★★★★         | 시간 조각별 카운트로 최근 요청 추적 | 정밀 제어, 경계 문제 거의 없음    | 구현 복잡, 시간 동기화 필요         | AWS API Gateway, Cloudflare 등     |

### 요약 한줄 설명:

- **토큰 버킷**: 실무에서 가장 널리 쓰이며, 일정한 비율로 토큰을 채워 유연하게 요청을 처리한다.
- **누출 버킷**: 단순히 일정한 속도로 요청을 처리해 QoS에 적합하지만, 트래픽 폭발에는 취약하다.
- **고정 윈도 카운터**: 간단하고 빠르게 구현 가능하나, 시간 경계에서 허점을 가질 수 있다.
- **이동 윈도 로그**: 정밀하나 메모리 부하가 커서 고성능 시스템에는 부적합하다.
- **이동 윈도 카운터**: 정밀성과 효율성을 모두 갖춰 클라우드 환경에서 가장 선호된다.       
  로그 vs 카운터 : (이동 윈도 카운터는 "모든 시점"을 기억하지 않고, "시간 구간 단위"로 유연하게 관리한다)     
  고정 윈도는 시간이 구간 정해져있고, 이동 윈도는 요청을 기준으로 시간간격이 정해짐!    
### 개략적인 아키텍쳐
이러한 카운터들을 어디에 보관할까?
우선 카운터는 디스크는 접근이 느리므로 캐시에 보관한다. (애초에 캐시는 휘발성이므로 카운터 저장에 적당함!)

## 3단계 상세 설계
1. 처리율 제한 규칙은 어떻게 만들어지고 어디에 저장되는가?
2. 처리가 제한된 요청들은 어떻게 처리되는가?

### 처리율 한도 초과 트래픽의 처리
큐에 보관했다가 나중에 처리하는 방법이 있다.

### 처리율 한도 초과 상치가 사용하는 HTTP 헤더
클라이언트입장에서 자기 요청이 제한에 걸리는지 어떻게 알까?
바로 처리율 제한 장치가 (필수는 아니고 그렇게 설계되었다면) 보내는 HTTP 헤더로 알 수 있다.
1.   X-RateLimit-Remaining : 윈도 내 남은 처리가능 요청 수
2.   X-RateLimit-Limit: 매 윈도의 크기
3.   X-RateLimit-Retry-After: 한도제한에 안 걸리려면 몇 초뒤에 보내야하는지
이러한 애들을 429(too-many-requests)오류 코드와 함꼐 보낸다.

### 상세설계
![KakaoTalk_Photo_2025-05-02-13-18-30](https://github.com/user-attachments/assets/8b97da08-b6d0-45d2-9c2b-4297841bea95)
1. 처리율 제한 규칙은 디스크에서 읽어 캐시해둔다.
2. 요청을 보내면 처리율 제한 미들웨어에 도착한다.
3. 처리율 제한 미들웨어가 제한규칙을 캐시에서 가져오고, 마지막 요청의 타임스탬프를 레디스 캐시에서 가져온다.
(타임스탬프는 요청 시각/Redis는 여러 분산서버에서 요청 기록을 공유하기 위한 빠른 저장소)
5. 타임스템프와 처리율 제한 규칙에 따라 처리하거나 버리거나 큐에넣는다.

### 분산환경에서의 처리율 제한 장치의 구현
1. 경쟁조건
2. 동기화이슈

### 1. 경쟁조건
가장 알려진 해결책은 락이나, 시스템 성능을 떨어뜨리기에 
루아스크립트나 정렬집합이라는(레디스 자료구조)를 사용가능

### 2. 동기화 이슈
처리율 제한 장치 서버를 여러개 두면 동기화가 필요한데, 고정세션으로처리할 수 있으나 이것은 확장이어렵고 유연성이 떨어진다.        
따라서 레디스와 같은 중앙집중형 데이터저장소를 쓰는 것이다.

### 성능 최적화
1. 데이터센터를 여러개 두어 지연시간을 감소시키자!
2. 제한장치간의 최종 일관성모델을 사용하자!
   - 최종 일관성 모델이란?(전파 지연이 있을 수 있지만, 시스템은 최종적으로 모든 노드에 동일한 값이 저장되도록 설계)
### 모니터링
모니터링을 통해 채택된 제한 알고리즘과 제한규칙이 효과적인지 확인하자.

## 4단계 마무리

경성 처리율 제한: 요청의 개수가 임계치를 넘어설 수 없다.
연성 처리율 제한: 요청의 개수가 잠시동안 임계치를 넘어설 수 있다.

이번 챕터에서는 애플리케이션계층인 (7layer)에서 알아보았지만 다른계층, 예로 ip를 사용하는 등 네트워크 계층에서도 해결가능하다.

### 클라이언트 측에선 설계를 어떻게 할까?
1. 캐시로 API호출 횟수를 줄인다.
2. 짧은 시간동안 너무 많은 메세지를 보내지않는다.
3. 에러나 예외 처리하는 코드를 도입하여 복구가 쉽도록 해라.
4. 재시도 로직은 충분한 백오프 시간을 둔다.
